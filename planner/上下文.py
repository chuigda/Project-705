from 公式 import *
from 技能 import *
from 猴子 import 猴子


class 计算上下文:
    def __init__(self, 猴: 猴子):
        self.猴 = 猴
        self.基础技能等级 = {
            '体魄': 0,
            '精神': 0
        }
        self.主科技能等级: dict[str, int] = dict()
        self.课余技能等级: dict[str, int] = dict()

        for 赛道 in 主科技能赛道:
            self.主科技能等级[赛道] = -1

        for 赛道 in 课余技能赛道:
            self.课余技能等级[赛道] = -1

        self.属性 = 0
        self.天赋 = 0
        self.回合 = 0
        self.技能点 = 200

        self.技能学习记录 = []
        self.技能数曲线 = []
        self.属性曲线 = []
        self.累计技能点曲线 = []

    def 计算这回合可以学什么(self) -> list[可用技能]:
        结果 = []
        if self.基础技能等级['体魄'] == 4 and self.基础技能等级['精神'] == 5:
            for 赛道 in 主科技能赛道:
                赛道等级 = self.主科技能等级[赛道] + 1
                if 赛道等级 >= len(主科技能赛道[赛道]):
                    continue
                基础消耗 = 技能基础消耗公式(赛道等级)
                属性需求 = 技能属性需求公式(赛道等级)
                实际消耗 = 技能消耗合成公式(基础消耗, 属性需求, self.属性)
                if 实际消耗 <= self.技能点:
                    技能名 = 主科技能赛道[赛道][赛道等级]
                    结果.append(可用技能(技能名, 赛道, 赛道等级, 基础消耗, 属性需求, 实际消耗, '主科'))
            for 赛道 in 课余技能赛道:
                if self.课余技能等级[赛道] is None:
                    self.课余技能等级[赛道] = \
                        赛道初始技能等级(课余技能赛道[赛道])
                    赛道等级 = self.课余技能等级[赛道] + 1
                    if 赛道等级 >= len(课余技能赛道[赛道]):
                        continue
                    基础消耗 = 技能基础消耗公式(赛道等级)
                    属性需求 = 技能属性需求公式(赛道等级)
                    实际消耗 = 技能消耗合成公式(基础消耗, 属性需求, self.属性)
                    if 实际消耗 <= self.技能点:
                        技能名 = 课余技能赛道[赛道][赛道等级]
                        结果.append(可用技能(技能名, 赛道, 赛道等级, 基础消耗, 属性需求, 实际消耗, '课余'))
        else:
            for 赛道 in 基础技能赛道:
                if self.基础技能等级[赛道] is None:
                    self.基础技能等级[赛道] = \
                        赛道初始技能等级(基础技能赛道[赛道])
                赛道等级 = self.基础技能等级[赛道] + 1
                if 赛道等级 >= len(基础技能赛道[赛道]):
                    continue
                基础消耗 = 技能基础消耗公式(赛道等级)
                属性需求 = 技能属性需求公式(赛道等级)
                实际消耗 = 技能消耗合成公式(基础消耗, 属性需求, self.属性)
                if 实际消耗 <= self.技能点:
                    技能名 = 基础技能赛道[赛道][赛道等级]
                    结果.append(可用技能(技能名, 赛道, 赛道等级, 基础消耗, 属性需求, 实际消耗, '基础'))

        结果.sort(key=get_所属赛道类别)
        结果.sort(key=get_等级, reverse=True)
        结果.sort(key=get_实际开销)
        return 结果

    def 重算技能消耗(self, 之前算的结果: list[可用技能]) -> list[可用技能]:
        结果 = []
        for 技能 in 之前算的结果:
            技能.实际消耗 = 技能消耗合成公式(技能.基础消耗, 技能.属性需求, self.属性)
            if 技能.实际消耗 <= self.技能点:
                结果.append(技能)
        return 结果

    def 最高技能等级(self) -> int:
        结果 = 0
        for 赛道 in self.基础技能等级:
            等级 = self.基础技能等级[赛道]
            结果 = max(结果, 等级)
        for 赛道 in self.主科技能等级:
            等级 = self.主科技能等级[赛道]
            结果 = max(结果, 等级)
        for 赛道 in self.课余技能等级:
            等级 = self.课余技能等级[赛道]
            结果 = max(结果, 等级)
        return 结果

    def 下一回合(self) -> bool:
        self.回合 += 1
        self.天赋 += 回合天赋增量公式(self.回合)
        self.属性 += self.天赋

        这回合可以学什么 = self.计算这回合可以学什么()
        while not len(这回合可以学什么) == 0:
            技能 = self.猴.选择学什么(self.回合, self.技能点, 这回合可以学什么)
            if 技能 is None:
                break

            self.技能学习记录.append((技能.赛道 + ':' + 技能.技能名, self.回合, 技能.基础消耗, 技能.实际消耗))
            self.属性 += 技能立即产出属性公式(技能.等级)
            if 技能.所属赛道类别 == '基础':
                先前等级 = self.基础技能等级[技能.赛道]
                self.基础技能等级[技能.赛道] = max(先前等级, 技能.等级)
            elif 技能.所属赛道类别 == '主科':
                先前等级 = self.主科技能等级[技能.赛道]
                self.主科技能等级[技能.赛道] = max(先前等级, 技能.等级)
            else:
                先前等级 = self.课余技能等级[技能.赛道]
                self.课余技能等级[技能.赛道] = max(先前等级, 技能.等级)

            这回合可以学什么.remove(技能)
            这回合可以学什么 = self.重算技能消耗(这回合可以学什么)

        self.技能数曲线.append(len(self.技能学习记录))
        技能等级 = self.最高技能等级()
        属性产出 = 技能活动产出属性公式(技能等级) * 6
        技能点产出 = 技能活动产出技能点公式(技能等级) * 6
        self.属性 += 属性产出
        self.技能点 += 技能点产出
        self.属性曲线.append(self.属性)
        self.累计技能点曲线.append(self.技能点)

        return self.回合 < 52
